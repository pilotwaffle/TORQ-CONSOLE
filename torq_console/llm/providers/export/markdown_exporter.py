"""
Markdown Exporter

Exports research results to formatted Markdown files.
"""

import logging
from typing import Dict, Any, Optional
from datetime import datetime
from pathlib import Path


class MarkdownExporter:
    """Export research results to Markdown format."""

    def __init__(self):
        """Initialize the Markdown exporter."""
        self.logger = logging.getLogger(__name__)

    def export(
        self,
        results: Dict[str, Any],
        output_path: str,
        include_metadata: bool = True,
        include_sources: bool = True,
        include_insights: bool = True
    ) -> bool:
        """
        Export results to Markdown file.

        Args:
            results: Research results dictionary
            output_path: Path to output Markdown file
            include_metadata: Include metadata section
            include_sources: Include source list
            include_insights: Include key insights

        Returns:
            True if export successful, False otherwise
        """
        try:
            markdown_content = self._generate_markdown(
                results,
                include_metadata,
                include_sources,
                include_insights
            )

            # Write to file
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
            output_file.write_text(markdown_content, encoding='utf-8')

            self.logger.info(f"[MARKDOWN] Exported to {output_path}")
            return True

        except Exception as e:
            self.logger.error(f"[MARKDOWN] Export failed: {e}")
            return False

    def _generate_markdown(
        self,
        results: Dict[str, Any],
        include_metadata: bool,
        include_sources: bool,
        include_insights: bool
    ) -> str:
        """Generate markdown content from results."""
        lines = []

        # Title
        query = results.get('query', 'Research Report')
        lines.append(f"# Research Report: {query}\n")

        # Metadata
        if include_metadata:
            lines.append(self._generate_metadata_section(results))

        # Summary
        if 'synthesis' in results:
            synthesis = results['synthesis']
            lines.append("## Summary\n")
            lines.append(f"{synthesis.get('summary', 'No summary available')}\n")

            # Confidence metrics
            lines.append(f"**Overall Confidence:** {synthesis.get('overall_confidence', 0):.2f}\n")
            lines.append(f"**Source Diversity:** {synthesis.get('source_diversity', 0):.2f}\n")
            lines.append(f"**Consensus Level:** {synthesis.get('consensus_level', 0):.2f}\n")

        # Key Insights
        if include_insights and 'synthesis' in results:
            lines.append(self._generate_insights_section(results['synthesis']))

        # Topics
        if 'synthesis' in results and results['synthesis'].get('topics'):
            lines.append(self._generate_topics_section(results['synthesis']['topics']))

        # Sources
        if include_sources:
            lines.append(self._generate_sources_section(results))

        # Contradictions
        if 'synthesis' in results and results['synthesis'].get('contradictions'):
            lines.append(self._generate_contradictions_section(results['synthesis']['contradictions']))

        # Footer
        lines.append("\n---\n")
        lines.append("*Generated by TORQ Console Phase 5: Export & UX*\n")

        return '\n'.join(lines)

    def _generate_metadata_section(self, results: Dict[str, Any]) -> str:
        """Generate metadata section."""
        lines = []

        timestamp = results.get('timestamp', datetime.now().isoformat())
        lines.append(f"**Generated:** {timestamp}")
        lines.append(f"**Query:** {results.get('query', 'N/A')}")

        if 'extracted_documents' in results:
            lines.append(f"**Sources Analyzed:** {len(results['extracted_documents'])}")

        if 'synthesis' in results:
            confidence = results['synthesis'].get('overall_confidence', 0)
            level = 'High' if confidence >= 0.75 else 'Medium' if confidence >= 0.50 else 'Low'
            lines.append(f"**Overall Confidence:** {confidence:.2f} ({level})")

        lines.append("")
        return '\n'.join(lines)

    def _generate_insights_section(self, synthesis: Dict[str, Any]) -> str:
        """Generate key insights section."""
        lines = ["## Key Insights\n"]

        insights = synthesis.get('key_insights', [])
        for i, insight in enumerate(insights, 1):
            text = insight.get('text', '')
            confidence = insight.get('confidence', 0)
            sources = insight.get('sources', [])

            lines.append(f"{i}. **{text}** (Confidence: {confidence:.2f})")

            if sources:
                source_refs = ', '.join([f"[{j+1}]" for j in range(len(sources))])
                lines.append(f"   - Sources: {source_refs}")

            lines.append("")

        return '\n'.join(lines)

    def _generate_topics_section(self, topics: list) -> str:
        """Generate topics section."""
        lines = ["## Topics Covered\n"]

        for topic in topics[:15]:  # Limit to top 15 topics
            lines.append(f"- {topic}")

        lines.append("")
        return '\n'.join(lines)

    def _generate_sources_section(self, results: Dict[str, Any]) -> str:
        """Generate sources section."""
        lines = ["## Sources\n"]

        # Get sources from results
        sources = []
        if 'extracted_documents' in results:
            sources = results['extracted_documents']
        elif 'results' in results:
            sources = results['results']

        # Get confidence scores if available
        confidence_scores = results.get('confidence_scores', [])

        for i, source in enumerate(sources, 1):
            title = source.get('title', 'Untitled')
            url = source.get('url', '')
            author = source.get('author', 'Unknown')
            date_published = source.get('date_published', 'Unknown')

            lines.append(f"[{i}] **{title}**")

            # Add confidence if available
            if i <= len(confidence_scores):
                score_data = confidence_scores[i-1]
                overall = score_data.get('overall_score', 0)
                level = score_data.get('level', 'unknown')
                lines.append(f"    Confidence: {overall:.2f} ({level})")
                lines.append(f"    Reliability: {score_data.get('source_reliability', 0):.2f} | "
                           f"Quality: {score_data.get('content_quality', 0):.2f} | "
                           f"Freshness: {score_data.get('freshness', 0):.2f}")

            lines.append(f"    URL: {url}")
            if author != 'Unknown':
                lines.append(f"    Author: {author}")
            if date_published != 'Unknown':
                lines.append(f"    Published: {date_published}")

            lines.append("")

        return '\n'.join(lines)

    def _generate_contradictions_section(self, contradictions: list) -> str:
        """Generate contradictions section."""
        if not contradictions:
            return ""

        lines = ["## Contradictions Detected\n"]

        for contradiction in contradictions:
            text = contradiction.get('text', '')
            source = contradiction.get('source', '')

            lines.append(f"- {text}")
            if source:
                lines.append(f"  (Source: {source})")
            lines.append("")

        return '\n'.join(lines)

    def export_to_string(self, results: Dict[str, Any]) -> str:
        """Export to markdown string without saving to file."""
        return self._generate_markdown(results, True, True, True)
